# POfeiY's Roads to Open Source - The Canvas Plum

2024/07/11

[Canvas Plum 2024](https://reactsummit.com/)

## Plum效果展示

使用canvas api绘制一颗小树,树枝的长度、生长角度在一定范围内是随机的（画框边界控制）

## Plum案例分析

### requestAnimationFrame

告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

将该API封装到hook中，循环调用生成Canvas树枝分叉，并且支持手动暂停与恢复动画执行

### Canvas

- ctx.beginPath
- ctx.moveTo
- ctx.lineTo
- ctx.stroke

- <b>二维坐标换算</b>

### 拓展学习：SVG or Canvas

Canvas 是基于脚本的，通过 JavaScript 指令来动态绘图。而 SVG 则是使用 XML 文档来描述矢量图。

Canvas 提供的绘图能力更底层，适合做到像素级的图形处理，能动态渲染和绘制大数据量的图形。而 SVG 抽象层次更高，声明描述式的接口功能更丰富，内置了大量的图形、滤镜和动画等，方便进行文档元素的维护，也能导出为文件脱离浏览器环境使用。

如果单就图表库的视角来看，选择 Canvas 和 SVG 各有千秋。小画布、大数据量的场景适合用 Canvas，譬如热力图、大数据量的散点图等。如果画布非常大，有缩放、平移等高频的交互，或者移动端对内存占用量非常敏感等场景，可以使用 SVG 的方案。

### 步进

起点
终点
线端
角度

### 帧动画

利用requestAnimationFrame帧动画实现每一层的树枝绘制与下一层树枝的计算工作

## 开发思路 & 步骤

1、初始化一张canvas画布，默认为400*400 大小，获取canvas的context
2、获取当前设备的dpr，设置为1，初始化canvas的基本属性如width\height等
3、设计步进逻辑，想象一样我们要在画布绘制一条直线需要什么，是不是需要确定起点和终点，再将起点与终点连接起来。这里我们可以先初始化模拟绘制一条线，起点为（0，0），终点为（0，20），然后划线连接，再涂色，可见我们的画布上出现一条线。好了，我们按照刚才的思路开始设计我们的树枝绘制步骤。

假设我们的树枝层级为5层，起点坐标手动指定，树枝的长度与方向也是随机生成，我们初始化定义一个步进任务队列与历史任务队列。首先将起止点指定后开始计算二维坐标，相信各位在做的老师们都精通正余弦公式，这里就不赘述了，通过夹角与随机长度值计算出起止点坐标，然后绘制；并且判断进行边界碰撞检测，如果未到边界则初始化下一层树枝绘制的起止点与夹角，装载到步进任务队列中。当然这里的层级可能绘制不到边界，所以我们加上一个随机数判断来增加绘制概率。
